#
# Copyright The CloudNativePG Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Default values for CloudNativePG.
# This is a YAML-formatted file.
# Please declare variables to be passed to your templates.

replicaCount: 1

image:
  repository: ghcr.io/cloudnative-pg/cloudnative-pg
  pullPolicy: IfNotPresent
  # -- Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

crds:
  # -- Specifies whether the CRDs should be created when installing the chart.
  create: true

# -- The webhook configuration.
webhook:
  port: 9443
  mutating:
    create: true
    failurePolicy: Fail
  validating:
    create: true
    failurePolicy: Fail
  livenessProbe:
    initialDelaySeconds: 3
  readinessProbe:
    initialDelaySeconds: 3

# -- Operator configuration.
config:
  # -- Specifies whether the secret should be created.
  create: true
  # -- The name of the configmap/secret to use.
  name: cnpg-controller-manager-config
  # -- Specifies whether it should be stored in a secret, instead of a configmap.
  secret: false
  # -- The content of the configmap/secret, see
  # https://cloudnative-pg.io/documentation/current/operator_conf/#available-options
  # for all the available options.
  data: {}
  # INHERITED_ANNOTATIONS: categories
  # INHERITED_LABELS: environment, workload, app
  # WATCH_NAMESPACE: namespace-a,namespace-b

# -- Additinal arguments to be added to the operator's args list.
additionalArgs: []

serviceAccount:
  # -- Specifies whether the service account should be created.
  create: true
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template.
  name: ""

rbac:
  # -- Specifies whether ClusterRole and ClusterRoleBinding should be created.
  create: true
  # -- Aggregate ClusterRoles to Kubernetes default user-facing roles.
  # Ref: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
  aggregateClusterRoles: false

# -- Annotations to be added to all other resources.
commonAnnotations: {}
# -- Annotations to be added to the pod.
podAnnotations: {}
# -- Labels to be added to the pod.
podLabels: {}

# -- Container Security Context.
containerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsUser: 10001
  runAsGroup: 10001
  capabilities:
    drop:
      - "ALL"

# -- Security Context for the whole pod.
podSecurityContext:
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault
  # fsGroup: 2000

# -- Priority indicates the importance of a Pod relative to other Pods.
priorityClassName: ""

service:
  type: ClusterIP
  # -- DO NOT CHANGE THE SERVICE NAME as it is currently used to generate the certificate
  # and can not be configured
  name: cnpg-webhook-service
  port: 443

resources: {}
  # If you want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  #
  # limits:
  #   cpu: 100m
  #   memory: 200Mi
  # requests:
  #   cpu: 100m
  #   memory: 100Mi

# -- Nodeselector for the operator to be installed.
nodeSelector: {}

# -- Tolerations for the operator to be installed.
tolerations: []

# -- Affinity for the operator to be installed.
affinity: {}

monitoring:
  # -- Specifies whether the monitoring should be enabled. Requires Prometheus Operator CRDs.
  podMonitorEnabled: false

# Default monitoring queries
monitoringQueriesConfigMap:
  # -- The name of the default monitoring configmap.
  name: cnpg-default-monitoring
  # -- A string representation of a YAML defining monitoring queries.
  queries: |
    pg_replication:
      query: "SELECT CASE WHEN (
                NOT pg_is_in_recovery()
                OR pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn())
              THEN 0
              ELSE GREATEST (0,
                EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())))
              END AS lag,
              pg_is_in_recovery() AS in_recovery,
              EXISTS (TABLE pg_stat_wal_receiver) AS is_wal_receiver_up,
              (SELECT count(*) FROM pg_stat_replication) AS streaming_replicas"

      metrics:
        - lag:
            usage: "GAUGE"
            description: "Replication lag behind primary in seconds"
        - in_recovery:
            usage: "GAUGE"
            description: "Whether the instance is in recovery"
        - is_wal_receiver_up:
            usage: "GAUGE"
            description: "Whether the instance wal_receiver is up"
        - streaming_replicas:
            usage: "GAUGE"
            description: "Number of streaming replicas connected to the instance"

    pg_postmaster:
      query: "SELECT pg_postmaster_start_time as start_time from pg_postmaster_start_time()"
      primary: true
      metrics:
        - start_time:
            usage: "GAUGE"
            description: "Time at which postgres started"

    pg_stat_user_tables:
      target_databases:
      - "*"
      query: |
       SELECT
         current_database() datname,
         schemaname,
         relname,
         seq_scan,
         seq_tup_read,
         idx_scan,
         idx_tup_fetch,
         n_tup_ins,
         n_tup_upd,
         n_tup_del,
         n_tup_hot_upd,
         n_live_tup,
         n_dead_tup,
         n_mod_since_analyze,
         COALESCE(last_vacuum, '1970-01-01Z') as last_vacuum,
         COALESCE(last_autovacuum, '1970-01-01Z') as last_autovacuum,
         COALESCE(last_analyze, '1970-01-01Z') as last_analyze,
         COALESCE(last_autoanalyze, '1970-01-01Z') as last_autoanalyze,
         vacuum_count,
         autovacuum_count,
         analyze_count,
         autoanalyze_count
       FROM
         pg_stat_user_tables
      metrics:
        - datname:
            usage: "LABEL"
            description: "Name of current database"
        - schemaname:
            usage: "LABEL"
            description: "Name of the schema that this table is in"
        - relname:
            usage: "LABEL"
            description: "Name of this table"
        - seq_scan:
            usage: "COUNTER"
            description: "Number of sequential scans initiated on this table"
        - seq_tup_read:
            usage: "COUNTER"
            description: "Number of live rows fetched by sequential scans"
        - idx_scan:
            usage: "COUNTER"
            description: "Number of index scans initiated on this table"
        - idx_tup_fetch:
            usage: "COUNTER"
            description: "Number of live rows fetched by index scans"
        - n_tup_ins:
            usage: "COUNTER"
            description: "Number of rows inserted"
        - n_tup_upd:
            usage: "COUNTER"
            description: "Number of rows updated"
        - n_tup_del:
            usage: "COUNTER"
            description: "Number of rows deleted"
        - n_tup_hot_upd:
            usage: "COUNTER"
            description: "Number of rows HOT updated (i.e., with no separate index update required)"
        - n_live_tup:
            usage: "GAUGE"
            description: "Estimated number of live rows"
        - n_dead_tup:
            usage: "GAUGE"
            description: "Estimated number of dead rows"
        - n_mod_since_analyze:
            usage: "GAUGE"
            description: "Estimated number of rows changed since last analyze"
        - last_vacuum:
            usage: "GAUGE"
            description: "Last time at which this table was manually vacuumed (not counting VACUUM FULL)"
        - last_autovacuum:
            usage: "GAUGE"
            description: "Last time at which this table was vacuumed by the autovacuum daemon"
        - last_analyze:
            usage: "GAUGE"
            description: "Last time at which this table was manually analyzed"
        - last_autoanalyze:
            usage: "GAUGE"
            description: "Last time at which this table was analyzed by the autovacuum daemon"
        - vacuum_count:
            usage: "COUNTER"
            description: "Number of times this table has been manually vacuumed (not counting VACUUM FULL)"
        - autovacuum_count:
            usage: "COUNTER"
            description: "Number of times this table has been vacuumed by the autovacuum daemon"
        - analyze_count:
            usage: "COUNTER"
            description: "Number of times this table has been manually analyzed"
        - autoanalyze_count:
            usage: "COUNTER"
            description: "Number of times this table has been analyzed by the autovacuum daemon"

    pg_statio_user_tables:
      query: "SELECT current_database() datname, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read, tidx_blks_hit FROM pg_statio_user_tables"
      metrics:
        - datname:
            usage: "LABEL"
            description: "Name of current database"
        - schemaname:
            usage: "LABEL"
            description: "Name of the schema that this table is in"
        - relname:
            usage: "LABEL"
            description: "Name of this table"
        - heap_blks_read:
            usage: "COUNTER"
            description: "Number of disk blocks read from this table"
        - heap_blks_hit:
            usage: "COUNTER"
            description: "Number of buffer hits in this table"
        - idx_blks_read:
            usage: "COUNTER"
            description: "Number of disk blocks read from all indexes on this table"
        - idx_blks_hit:
            usage: "COUNTER"
            description: "Number of buffer hits in all indexes on this table"
        - toast_blks_read:
            usage: "COUNTER"
            description: "Number of disk blocks read from this table's TOAST table (if any)"
        - toast_blks_hit:
            usage: "COUNTER"
            description: "Number of buffer hits in this table's TOAST table (if any)"
        - tidx_blks_read:
            usage: "COUNTER"
            description: "Number of disk blocks read from this table's TOAST table indexes (if any)"
        - tidx_blks_hit:
            usage: "COUNTER"
            description: "Number of buffer hits in this table's TOAST table indexes (if any)"

    pg_stat_activity:
      query: |
        WITH
          metrics AS (
            SELECT
              application_name,
              SUM(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - state_change))::bigint)::float AS process_idle_seconds_sum,
              COUNT(*) AS process_idle_seconds_count
            FROM pg_stat_activity
            WHERE state = 'idle'
            GROUP BY application_name
          ),
          buckets AS (
            SELECT
              application_name,
              le,
              SUM(
                CASE WHEN EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - state_change)) <= le
                  THEN 1
                  ELSE 0
                END
              )::bigint AS bucket
            FROM
              pg_stat_activity,
              UNNEST(ARRAY[1, 2, 5, 15, 30, 60, 90, 120, 300]) AS le
            GROUP BY application_name, le
            ORDER BY application_name, le
          )
        SELECT
          application_name,
          process_idle_seconds_sum,
          process_idle_seconds_count,
          ARRAY_AGG(le) AS process_idle_seconds,
          ARRAY_AGG(bucket) AS process_idle_seconds_bucket
        FROM metrics JOIN buckets USING (application_name)
        GROUP BY 1, 2, 3
      metrics:
        - application_name:
            usage: "LABEL"
            description: "Application Name"
        - process_idle_seconds:
            usage: "HISTOGRAM"
            description: "Idle time of server processes"
